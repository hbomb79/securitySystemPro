--os.pullEvent = os.pullEventRaw Termination Defence Layer 1!
isRunning = true
termX, termY = term.getSize()

rsText = 'Side: '
rsTimeText = 'Time: '



current = {
  Settings = {
    Whitelist = {}
  },
}
current.status = 'Booting! '
security = {}
_int = 1
_string = 'a'
function readN(len, replaceChar)
  Num = false
  term.setTextColor(1)
  len = len or 10
  local input=""
  local key = 0
  term.setCursorBlink(true)
  repeat
        e,p1 = os.pullEvent()
		  if p1 == "0" or p1 == "1" or p1 == "2" or p1 == "3" or p1 == "4" or p1 == "5" or p1 == "6" or p1 == "7" or p1 == "8" or p1 == "9" then
		    p1 = tonumber(p1)
		    Num = true
		  elseif type(p1) == type(_string) then
		    term.setTextColor(colors.red)
		    Num = "Word"
		    return Num
		  end
        if e=="char" then
          if #input < len then
		    if type(p1) == type(_int) then
                input = input .. p1
                term.write(replaceChar or p1)
			end
          end
        elseif e=="key" and p1==keys.backspace and #input > 0 then
          input = input:sub(1,#input-1)
          local x,y = term.getCursorPos()
          term.setCursorPos(x-1,y)
          term.write(" ")
          term.setCursorPos(x-1,y)
        end
  until p1==keys.enter
  term.setCursorBlink(false)
  return input
end


Peripheral = {
	GetPeripheral = function(_type)
		for i, p in ipairs(Peripheral.GetPeripherals()) do
			if p.Type == _type then
				return p
			end
		end
	end,

	Call = function(type, ...)
		local tArgs = {...}
		local p = GetPeripheral(type)
		peripheral.call(p.Side, unpack(tArgs))
	end,

	GetPeripherals = function(filterType)
		local peripherals = {}
		for i, side in ipairs(peripheral.getNames()) do
			local name = peripheral.getType(side):gsub("^%l", string.upper)
			local code = string.upper(side:sub(1,1))
			if side:find('_') then
				code = side:sub(side:find('_')+1)
			end

			local dupe = false
			for i, v in ipairs(peripherals) do
				if v[1] == name .. ' ' .. code then
					dupe = true
				end
			end

			if not dupe then
				local _type = peripheral.getType(side)
				local isWireless = false
				if _type == 'modem' then
					if not pcall(function()isWireless = peripheral.call(sSide, 'isWireless') end) then
						isWireless = true
					end     
					if isWireless then
						_type = 'wireless_modem'
						name = 'W '..name
					end
				end
				if not filterType or _type == filterType then
					table.insert(peripherals, {Name = name:sub(1,8) .. ' '..code, Fullname = name .. ' ('..Capitalise(side)..')', Side = side, Type = _type, Wireless = isWireless})
				end
			end
		end
		return peripherals
	end,

	GetPeripheral = function(_type)
		for i, p in ipairs(Peripheral.GetPeripherals()) do
			if p.Type == _type then
				return p
			end
		end
	end,

	PresentNamed = function(name)
		return peripheral.isPresent(name)
	end,

	CallType = function(type, ...)
		local tArgs = {...}
		local p = Peripheral.GetPeripheral(type)
		return peripheral.call(p.Side, unpack(tArgs))
	end,

	CallNamed = function(name, ...)
		local tArgs = {...}
		return peripheral.call(name, unpack(tArgs))
	end
}

Capitalise = function(str)
	return str:sub(1, 1):upper() .. str:sub(2, -1)
end

function downloadFail(errCode)
  term.clear()
  term.setTextColor(colors.black)
  term.setBackgroundColor(1)
  term.setCursorPos(1,1)
  print('An error occured while downloading APIs to the pocket PC')
  print()
  print(errCode)
  print()
  print('Rebooting!')
  sleep(3)
  os.reboot()
end


function downloadFiles(getUrl, toPath) --Used to download stuff!!
  for i = 1, 3 do
    local response = http.get(getUrl)
	if response then
	  data = response.readAll()
	      if fs.exists(toPath) then
		  fs.delete(toPath)
		end
		if toPath then
		  local file = io.open(toPath, "w")
		  file:write(data)
		  file:close()
		  return true
		else
		  downloadFail('An Error Occurred While Saving To Path: '..toPath)
		end
	else
	  downloadFail('The Url: '..getUrl..' Does Not Appear To Exist! Please Try Again')
	end
  end
  downloadFail('The Request Timed Out')
end


function pocketAPI() --Downloads And Installs The APIs Required To Run The Program
  if not fs.exists('api') then
    term.setTextColor(1)
	term.setBackgroundColor(256)
	term.clear()
	print('Please Wait While We Download All The APIs Needed To Use The Program!')
    downloadFiles("https://raw.githubusercontent.com/hbomb79/securitySystemPro/master/api/download", "/api/download")
    downloadFiles("https://raw.githubusercontent.com/hbomb79/securitySystemPro/master/api/systemCheck", "/api/systemCheck")
    downloadFiles("https://raw.githubusercontent.com/hbomb79/securitySystemPro/master/api/update", "/api/update")
    downloadFiles("https://raw.githubusercontent.com/hbomb79/securitySystemPro/master/api/printer", "/api/printer")
    downloadFiles("https://raw.githubusercontent.com/hbomb79/securitySystemPro/master/api/titleBar", "/api/titleBar")
    downloadFiles("https://raw.githubusercontent.com/hbomb79/securitySystemPro/master/api/errora", "/api/errora")
    downloadFiles("https://raw.githubusercontent.com/hbomb79/securitySystemPro/master/version", "version")
  end
  return true
end

function hostSetup() --Creates The Setup GUI If The Config File Is Not Found
  local function setupTitleBar()
	titleBar.draw('HbombOS Secuity Suite', 'Range Detector Setup', colors.cyan, 256, 128, 256, 1)
  end
  
  local function welcome()
    setupTitleBar()
    printer.centered('It appears you have not yet used this', 6)
    printer.centered('program before', 7)
    printer.centered('Click Anywhere On Screen To Get Started!', 10)
	os.pullEvent('mouse_click')
  end
  
  local function redstoneOutSide()
   while true do
    setupTitleBar()
	printer.centered("Redstone Output Side", 6)
	term.setCursorPos(termX/2-(#rsText),10)
	  write (rsText)
	  local vside = false
		current.Settings.redstoneOutsideSetup = read()
		for k,v in pairs(rs.getSides()) do
			if v == current.Settings.redstoneOutsideSetup then
				vside = true
				break
			end
		end
		if vside then break end
		  printer.centered("Invalid side!", 11)
		  sleep(0.5)
		  term.clear()
		end
	 return
  end
  
  local function redstoneInputOption()
  while true do
    setupTitleBar()
	printer.centered('Would You Like The Computer To Emit A Redstone', 6)
	printer.centered('Signal If It Receives A Redstone Signal', 7)
	printer.centered('You Pick Which Side The Input Has To Be Applied To', 9)
	printer.centered('On The Next Screen', 10)
	printer.centered('Press Y To Enable, N To Disable', 12)
	event, key = os.pullEvent('key')
	  if key == keys.y then
	    current.Settings.inputOption = true
		return true
	  elseif key == keys.n then
	    current.Settings.inputOption = false
	    return false
	  end
	end
  end
  
  local function redstoneInputSide()
  sleep(0)
    while true do
    setupTitleBar()
	printer.centered("Redstone Input Side", 6)
	term.setCursorPos(termX/2-(#rsText),10)
	  write (rsText)
	  local vside = false
		current.Settings.redstoneInsideSetup = read()
		for k,v in pairs(rs.getSides()) do
			if v == current.Settings.redstoneInsideSetup then
				vside = true
				break
			end
		end
		if vside then break end
		  printer.centered("Invalid side!", 11)
		  sleep(0.5)
		  term.clear()
		end
	 return
  end
  
  local function distance()
  while true do
      setupTitleBar()
	  printer.centered('At What Proximity To The Computer Do', 6)
	  printer.centered('You Want To Be When It Emits A Redstone Signal', 7)
	  distanceText = 'Distance(In Blocks): '
	  term.setCursorPos(termX/2-#distanceText, 10)
	  write (distanceText)
	 distanceInput = readN(2)
	 if distanceInput ~= "" then
	    distanceInput = tonumber(distanceInput)
	      if distanceInput <=64 then current.Settings.distance = distanceInput break end
	  end
    end
  end
  
  local function saveSetup()
    setupTitleBar()
    printer.centered('Thank You For Setting Up Your RangeLock', 6)
	printer.centered('Secuity System! Please Report Any Bugs', 8)
    printer.centered('Saving Settings', 19)
	sleep(0)
    SaveSettings()
	printer.centered('Click Anywhere To Reboot', 19)
	os.pullEvent('mouse_click')
	os.reboot()
  end
  
--Call all the functions in order to setup the system!
welcome()
redstoneOutSide()
distance()
if redstoneInputOption() then redstoneInputSide() end
saveSetup()
end

-- Modem Functions Called For Info On Modems, Or To Change Modem Status
modem = {
  channels = {
    ping = 6019,
    request = 6021,
	reply = 6023,
  },
  isOpen = function(channel) --Returns if the channel is open or not
    Peripheral.CallType('wireless_modem', 'isOpen', channel)
  end,
  
  Open = function(channel) --Open a channel if not already open
    if not modem.isOpen(channel) then
	  Peripheral.CallType('wireless_modem', 'open', channel)
	end
  end, 
  
  Close = function(channel) --Close channel specified
    Peripheral.CallType('wireless_modem', 'close', channel)
  end,
  
  CloseAll = function() --Close all channels
    Peripheral.CallType('wireless_modem', 'closeAll')
  end, 
  
  Transmit = function(channel, replyChannel, message) --Transmit a message over the modem... The message is serialized first so it can hold data.... Use FormatMessage()
    Peripheral.CallType('wireless_modem', 'transmit', channel, replyChannel, textutils.serialize(message))
  end,
  	
  isPresent = function()
    if Peripheral.GetPeripheral('wireless_modem') == nil then
	  return false
	else
	  return true
	end
  end,

  RecieveMessage = function(_channel, messageID, timeout)
		open(_channel)
		local done = false
		local event, side, channel, replyChannel, message = nil
		Timeout(function()
			while not done do
				event, side, channel, replyChannel, message = os.pullEvent('modem_message')
				if channel ~= _channel then
					event, side, channel, replyChannel, message = nil
				else
					message = textutils.unserialize(message)
					message.content = textutils.unserialize(message.content)
					if messageID and messageID ~= message.messageID or (message.destinationID ~= nil and message.destinationID ~= os.getComputerID()) then
						event, side, channel, replyChannel, message = nil
					else
						done = true
					end
				end
			end
		end,
		timeout)
		return event, side, channel, replyChannel, message
	end,

  SendMessage = function(channel, message, reply, messageID, destinationID)
    reply = reply or modem.channels.reply
	modem.Open(channel)
	modem.Open(reply)
	local _message = modem.FormatMessage(message, messageID, destinationID)
	modem.Transmit(channel, reply, _message)
	return _message
  end,

  HandleMessage = function(event, side, channel, replyChannel, message, distance)
    message = textutils.unserialize(message)
	message.content = textutils.unserialize(message.content)
	  if channel == modem.channels.ping and message.content == 'Ping!' and not pocket then
		modem.SendMessage(replyChannel, 'Pong!', nil, message.messageID)
	  elseif channel == modem.channels.ping and message.content == 'Ping!' and pocket then
	    modem.SendMessage(replyChannel, current.Fingerprint, nil, message.messageID)
	  elseif message.destinationID ~= nil and message.destinationID ~= os.getComputerID() then
	  elseif modem.Responder then
	    modem.Responder(event, side, channel, replyChannel, message, distance)
	  end
  end,

  FormatMessage = function(message, messageID, destinationID)
    return {
	  content = textutils.serialize(message),
  	  senderID = os.getComputerID(),
	  senderName = os.getComputerLabel(),
	  channel = channel,
	  replyChannel = reply,
	  messageID = messageID or math.random(10000),
	  destinationID = destinationID
    }
  end,
  
	Initialise = function()
		if modem.isPresent() then
			for i, c in pairs(modem.channels) do
				modem.Open(c)
			end
		end
	end,
}

Events ={}

function createFingerprint() --Saves the fingerprint to the PDA
  if not fs.exists('.fingerprint') then
    local fingerprint = generateFingerprint() --Generates the finger print and stores it in a variable
	current.Settings.Whitelist = fingerprint --Stores the fingerprint in the table 'Settings'
  else
    os.reboot()
  end
end

function generateFingerprint()
 local fingerprint = ""
  for i=1, 256 do --Repeats 256 times
    char = math.random(32, 126) --Creates A Random Digit
	fingerprint = fingerprint .. string.char(char) --Adds the random digit on the end of the others
  end
  return fingerprint  --Returns the fingerprint completed after the loop has finished
end

function pingPDA()
  modem.SendMessage(modem.channels.ping, 'Ping!', modem.channels.request)
  pingTimer = os.startTimer(0.5)
end

local DoorTimer = nil
function OpenDoor()
	if current.Settings.redstoneOutsideSetup then
		redstone.setOutput(current.Settings.redstoneOutsideSetup, true)
		DoorTimer = os.startTimer(0.5)
	end
end
function CloseDoor()
    current.Allow = false
	current.Denied = false
	if current.Settings.redstoneOutsideSetup then
	  redstone.setOutput(current.Settings.redstoneOutsideSetup, false)
	end
end

function loadSettings()
  if fs.exists('systemFiles/Programs/rangeLockSettings') then
		local f = fs.open('systemFiles/Programs/rangeLockSettings', 'r')
		if f then
			current.Settings = textutils.unserialize(f.readAll())
		end
		f.close()
	else
		hostSetup()
	end
end

function SaveSettings()
	current.Settings = current.Settings or {}
	local f = fs.open('systemFiles/Programs/rangeLockSettings', 'w')
	if f then
		f.write(textutils.serialize(current.Settings))
	end
	f.close()	
end

function eventRegister(event, functionToRun)
	if not Events[event] then
		Events[event] = {}
	end
	table.insert(Events[event], functionToRun)
end

function RegisterPDA()
while true do
 sleep(0)
  titleBar.draw('HbombOS Secuity Suite', 'RangeLock Registration', colors.cyan, 256, 128, 256, 1)
  printer.centered('Please Insert Your PDA Into A Disk Drive', 6)
  printer.centered('Attached To This Computer', 7)
  printer.centered('Press [ALT] To Reload Settings And Return', 19)
  event, side = os.pullEvent()
  if event == 'disk' then
	if disk.hasData(side) then
		local path = disk.getMountPath(side)
		local fingerprint = nil
		if fs.exists(path..'/.fingerprint') then
			local h = fs.open(path..'/.fingerprint', 'r')
			if h then
				local str = h.readAll()
				if #str == 256 then
					fingerprint = str
				end
			end
			h.close()
		else
		end
		if not fingerprint then
			fingerprint = generateFingerprint()
			local h = fs.open(path..'/.fingerprint', 'w')
			h.write(fingerprint)
			h.close()
			addStartup = true
			if addStartup then
				local h = fs.open('systemFiles/Programs/rangeLock', 'r')
				local startup = h.readAll()
				h.close()
				local h = fs.open(path..'/startup', 'w')
				h.write(startup)
				h.close()
			end
		end
		if not FingerprintIsOnWhitelist(fingerprint) then
			table.insert(current.Settings.Whitelist, fingerprint)
			SaveSettings()
		end  
		  disk.eject(side)
          printer.centered('PDA Registered', 19)
          sleep(1)
	end
  elseif event == 'key' then
    if side == keys.leftAlt or side == keys.rightAlt then initialise() break end
  end
end
  return
end

function removeProgram()
while true do
 sleep(0)
  titleBar.draw('HbombOS Secuity Suite', 'RangeLock Remove', colors.cyan, 256, 128, 256, 1)
  printer.centered('Please Insert Your PDA Into A Disk Drive', 6)
  printer.centered('Attached To This Computer', 7)
  printer.centered('Press [ALT] To Reload Settings And Return', 19)
  event, side = os.pullEvent()
  if event == 'disk' then
	if disk.hasData(side) then
		local path = disk.getMountPath(side)
		local fingerprint = nil
		if fs.exists(path..'/.fingerprint') then --Removes Fingerprint
		  fs.delete(path..'/.fingerprint')
		end
		if fs.exists(path..'/startup') then --Removes Startup File
		  fs.delete(path..'/startup')
		end
		if fs.exists(path..'/api/') then --Removes API Directory And Contents
		  fs.delete(path..'/api/')
		end
		if fs.exists(path..'/version') then --Removes the version file
		  fs.delete(path..'/version')
		end
		disk.eject(side)
		printer.centered('All Data On PDA Removed', 19)
		sleep(1)
	end
  elseif event == 'key' then
    if side == keys.leftAlt or side == keys.rightAlt then initialise() break end
  end
end
  return
end

function unRegisterPDA()
while true do
 sleep(0)
  titleBar.draw('HbombOS Secuity Suite', 'RangeLock Un-Registration', colors.cyan, 256, 128, 256, 1)
  printer.centered('Please Insert Your PDA Into A Disk Drive', 6)
  printer.centered('Attached To This Computer', 7)
  printer.centered('Press [ALT] To Reload Settings And Return', 19)
  event, side = os.pullEvent()
  if event == 'disk' then
	if disk.hasData(side) then
		local path = disk.getMountPath(side)
		local fingerprint = nil
		if fs.exists(path..'/.fingerprint') then
		  fs.delete(path..'/.fingerprint')
		end
		disk.eject(side)
        printer.centered('PDA Un-registered', 19)
        sleep(1)
	end
  elseif event == 'key' then
    if side == keys.leftAlt or side == keys.rightAlt then initialise() break end
  end
end
  return
end

function FingerprintIsOnWhitelist(fingerprint)
	if current.Settings.Whitelist then
		for i, f in ipairs(current.Settings.Whitelist) do
			if f == fingerprint then
				return true
			end
		end
	end
	return false
end

function nomodem()
  titleBar.draw('HbombOS Security Suite', 'RangeLock', colors.cyan, 256, 128, 256, 1)
  if pocket then
    print('Please Add A Wireless Modem To This PDA')
	print()
	print('Click Anywhere To Reboot')
  else
    printer.centered('Please Attach A Wireless Modem To This Computer', 6)
	printer.centered('Click Anywhere To Reboot', 19)
  end
  os.pullEvent('mouse_click')
  os.reboot()
end

function startHost() --Register Function ' Wireless.Responder' On Host Computer To Check Fingerprint Sent By PDA
  if not modem.isPresent() then
    nomodem()
  end
 modem.Initialise()
 modem.Responder = function(event, side, channel, replyChannel, message, distance)
  if channel == modem.channels.request and distance < current.Settings.distance then
    if FingerprintIsOnWhitelist(message.content) then
	  modem.SendMessage(modem.channels.reply, true)
	  current.Allow = true
	  current.Denied = false
	  getStatus()
	  OpenDoor()
	else
	  current.Allow = false
	  current.Denied = true
	  getStatus()
	  modem.SendMessage(modem.channels.reply, false)
	  refreshTimer = os.startTimer(0)
	end
  end
  if distance > current.Settings.distance then 
    modem.SendMessage(modem.channels.reply, 'OutOfRange')
	current.Denied = false
	getStatus()
  end  
 end
--[[if current.Status == 'Access Denied!' then term.setTextColor(colors.red) elseif current.Status == 'Access Granted!' then term.setTextColor(colors.lime) end
printer.centered(current.status, 8)
term.setTextColor(1)]]--
pingPDA()
end


function getStatus()
 local function hostStatus()
    if current.Allow then
	  current.status = ('Access Granted!')
	elseif current.Denied then
	  current.status = ('Access Denied!')
	else
	  current.status = ('System Ready!')
	end
  end
  
  local function PDAstatus()
    if current.Denied then
      current.status = 'Access Denied!'
    elseif current.Allow then
      current.status = 'Access Granted!'
    else
      current.status = 'System Ready!'
    end
	printer.centered(current.status, 8)
  end
  if pocket then PDAstatus() else hostStatus() end
end

function startPDA() --Registers Function 'Wireless.Responder' On PDA To Show Status Of Door
if not modem.isPresent() then
  nomodem()
end
modem.Initialise()
if not fs.exists('api') then pocketAPI() end --Checks for apis and downloads them
os.loadAPI('/api/download') --Download.git Api, Just here for convenience
os.loadAPI('/api/systemCheck') --System Checker
os.loadAPI('/api/update') --Update Checker
os.loadAPI('/api/printer') --printer.centered
os.loadAPI('/api/titleBar') --Title Bar Drawing Method
os.loadAPI('/api/errora') --Custom Blue Screen Of Death Syntax: Error Code, Error Message, Autoreboot[Boolean]

updateState = update.Check()

if updateState == 'ERROR' then errora.err('The Update Checker Ran Into An Issue!', 'Error Received', true) elseif updateState == true then pocketAPI() end --Checks For An Update On Github And Downloads

if not modem.isPresent() then
  term.clear()
  print('Please Attach A Wireless Modem To Continue')
end
  if fs.exists('.fingerprint') then
    local h = fs.open('.fingerprint', 'r')
      if h then
        current.Fingerprint = h.readAll()
	  else
  	    createFingerprint()
	  end
	  h.close()
  else
    createFingerprint()
  end

	modem.Responder = function(event, side, channel, replyChannel, message, distance)
		if channel == modem.channels.ping then
			modem.SendMessage(modem.channels.request, current.Fingerprint, modem.channels.reply, nil, message.senderID)
		elseif channel == modem.channels.reply then
			if message.content == true then
              current.Allow = true
			  current.Denied = false
			elseif message.content == false then
			  current.Allow = false
			  current.Denied = true
			else
			  current.Allow = false
			  current.Denied = false
			end
		end
	end
--getStatus()
--printer.centered(current.status, 8)
end

function timerHandler(event, timer) --Handles timer completion events and carries out the appropriate action
  if timer == pingTimer then
    pingPDA()
  elseif timer == DoorTimer then
    CloseDoor()
  elseif timer == refreshTimer then
	getStatus()
  end
end

function checkConfig()
  config = true
  term.clear()
  titleBar.draw('HbombOS Security Suite', 'RangeLock', colors.cyan, 256, 128, 256, 1)
  printer.centered('Please Enter Your Administartor Password', 6)
  printer.centered('To Access Your Configuration Options', 7)
  local f = fs.open('systemFiles/Security/adminPass', 'r')
  adminPassFile = f.readLine()
  f.close()
  configText = 'Password: '
  term.setCursorPos(termX/2-#configText, 10)
  write(configText)
  configInput = read('*')
  if configInput == adminPassFile then config = true configMenu() else printer.centered('Incorrect Password.. Returning', 19) sleep(0.5) return end
end

function keyPress(event, key)
  if key == keys.leftAlt or key == keys.rightAlt then checkConfig() end
end

function configMenu()
  titleBar.draw('HbombOS Security Suite', 'RangeLock Settings', colors.cyan, 256, 128, 256, 1)
  printer.centered('Pick An Option Below', 6)
  local continue = false
  local options = {
  	    {'Register Pocket Computers', function()
          RegisterPDA()
		end},
		{'Unregister Pocket Computers', function() 
		  unRegisterPDA()
		end}, 
		{'Remove Files From PDA', function()
		  removeProgram()
		end}, 
		{'Reset Config', function()
		  fs.delete('systemFiles/Programs/rangeLockSettings')
		  pressed = false
		  config = true
		  printer.centered('Removed!', 19)
		  sleep(1)
		  os.reboot()
		end},
		{'Cancel', function()
          return
		end}
	}
	local selected = 1
	local function draw()
		for i, v in ipairs(options) do
			local bg = 256
			local tc = colours.white
			if i == selected then
				bg = 256
				tc = colours.blue
			end
			term.setTextColor(tc)
			term.setBackgroundColor(bg)
			PrintCentered(' '..v[1]..' ', math.floor(#options/2) + i + 6)
		end
	end
	local wait = true
	draw()
	while wait do
		local event, key = os.pullEvent('key')
		if key == keys.up then
			selected = selected - 1
			if selected < 1 then
				selected = 1
			end
		elseif key == keys.down then
			selected = selected + 1
			if selected > #options then
				selected = #options
			end
		elseif key == keys.enter then
		  options[selected][2]()
		  wait = false
		end
		draw()
	end
	return continue
end

function initialise() --Registers All Events To Autorun Functions, e.g If I press a key it will run keyPress
  if not pocket then eventRegister('key', keyPress) end
  eventRegister('timer', timerHandler)
  eventRegister('terminate', function(event) errora.err('Termination Detected', 'You Attempted To Terminate The Program!' , true) end)
  eventRegister('modem_message', modem.HandleMessage)
  --Loading Configuration
  modem.Initialise()
  if pocket then
    startPDA() --Configures The PDA Responder Function
  else
    loadSettings()
    startHost() --Set up the host system
  end
  eventLoop() --Starts the program waiting for the events to occur
end


function eventLoop() --This runs the functions that was assigned to the event in initialise()
  while isRunning do
    term.clear()
    titleBar.draw('HbombOS Security Suite', 'Range Lock', colors.cyan, 256, 128, 256, 1)
    term.setTextColor(1)
    printer.centered('Range Lock Security', 6)    
	getStatus()
    if current.status == 'Access Denied!' then term.setTextColor(colors.red) elseif current.status == 'Access Granted!' then term.setTextColor(colors.lime) elseif current.status == 'System Ready!' then term.setTextColor(colors.blue) end
	printer.centered(current.status, 8)
    term.setTextColor(1)
    if not pocket then printer.centered('Press [alt] To Enter Setup', 19) end
	local event, arg1, arg2, arg3, arg4, arg5, arg6 = os.pullEventRaw()
	  if Events[event] then
		for i, e in ipairs(Events[event]) do
		  e(event, arg1, arg2, arg3, arg4, arg5, arg6)
		end
      end
   end
end


function loadAPIS()
  os.loadAPI('api/errora')
  os.loadAPI('api/update')
  os.loadAPI('api/titleBar')
  os.loadAPI('api/systemCheck')
  os.loadAPI('api/download')
  os.loadAPI('api/printer')
end

if not term.isColor() then
  printer.centered('The Software Requires An Advanced Machine Run', 19)
  sleep(3)
  os.shutdown()
end
  local _, err = pcall(initialise) --Error Catching, All Functions Are Called From initialise() at some point...
  if err then
    term.setCursorBlink(false)
    loadAPIS()
	errora.err(err, 'Range Lock Has Crashed', true) --BSoD for protection, the 'true' is an auto-reboot option to prevent the door waiting for a prompt
  end