Events ={}
current = {
  Settings = {}
}

current.Disks = 0
current.ValidDisks = 0
current.InvalidDisks = 0
current.Status = 'System Ready'

isRunning = true
_int = '1'
_string = "a"

function readN(len, replaceChar, HasToBeNum)
  Num = false
  term.setTextColor(1)
  len = len or 10
  local input=""
  local key = 0
  term.setCursorBlink(true)
  repeat
        e,p1 = os.pullEvent()
		  if p1 == "0" or p1 == "1" or p1 == "2" or p1 == "3" or p1 == "4" or p1 == "5" or p1 == "6" or p1 == "7" or p1 == "8" or p1 == "9" then
		    --p1 = tonumber(p1)
		    Num = true
		  elseif type(p1) == type(_string) then
		    term.setTextColor(colors.red)
		    Num = "Word"
		    return Num
		  end
        if e=="char" then
          if #input < len then
		    if type(p1) == type(_int) then
                input = input .. p1
                term.write(replaceChar or p1)
			end
          end
        elseif e=="key" and p1==keys.backspace and #input > 0 then
          input = input:sub(1,#input-1)
          local x,y = term.getCursorPos()
          term.setCursorPos(x-1,y)
          term.write(" ")
          term.setCursorPos(x-1,y)
        end
  until p1==keys.enter
  term.setCursorBlink(false)
  return input
end

function SaveSettings()
	current.Settings = current.Settings or {}
	local f = fs.open('systemFiles/Programs/KeyDualConfig', 'w')
	if f then
		f.write(textutils.serialize(current.Settings))
	end
	f.close()	
end

function loadSettings()
  if fs.exists('systemFiles/Programs/KeyDualConfig') then
		local f = fs.open('systemFiles/Programs/KeyDualConfig', 'r')
		if f then
			current.Settings = textutils.unserialize(f.readAll())
		end
		f.close()
	else
		Setup()
	end
end

function eventHandler()
  while isRunning do
  drawScreen()
	local event, arg1, arg2, arg3, arg4, arg5, arg6 = os.pullEventRaw()
	  if Events[event] then
		for i, e in ipairs(Events[event]) do
		  e(event, arg1, arg2, arg3, arg4, arg5, arg6)
		end
      end
   end
end

function redstoneInputDetect(event)
  while true do
    if rs.getInput(current.Settings.redstoneInputSide) then
      openSide()
    end
  end
end

function initialise()
  drawTitle()
  printer.centered('Registering Events', 6)
  eventRegister('disk', diskInsert)
  eventRegister('disk_eject', diskRemove)
  eventRegister('terminate', function(event) errora.err('Uh Oh!', 'Termination Detected, Thats Naughty', true) end)
  eventRegister('redstone', redstoneInputDetect)  
  eventRegister('timer', timerHandler)  
  printer.centered('Loading Configuration File...', 6)
  loadSettings()
  printer.centered('Load Complete', 6)
  sleep(0)
  eventHandler()
end

function eventRegister(event, functionToRun)
	if not Events[event] then
		Events[event] = {}
	end
	table.insert(Events[event], functionToRun)
end

function drawTitle()
  titleBar.draw('HbombOS Secuity Suite', 'Keycard Dual', colors.cyan, 256, 128, 256, 1)
end

function Setup() --Creates The Setup GUI If The Config File Is Not Found
  local function setupTitleBar()
	titleBar.draw('HbombOS Secuity Suite', 'Keycard Dual Setup', colors.cyan, 256, 128, 256, 1)
  end
  
  function welcome()
    setupTitleBar()
	printer.centered('It Appears You Have Not Used This Program Before', 6)
	printer.centered('This Wizzard Will Guide You Through Setup', 7)
	printer.centered('Simply Click Anywhere On Screen To Start!', 10)
  end
  
  diskText = 'Side: '
  local function diskSide1()
  while true do
    setupTitleBar()
	printer.centered("On What Side Is The First Disk Drive On?", 6)
	term.setCursorPos(termX/2-(#diskText),10)
	  write (diskText)
	  local vside = false
		diskDriveSide1 = read()
		for k,v in pairs(rs.getSides()) do
			if v == diskDriveSide1 then
				vside = true
				current.Settings.diskSide1 = diskDriveSide1
				break
			end
		end
		if vside then break end
		  printer.centered("Invalid side!", 10)
		  sleep(0.5)
		  term.clear()
		end
  end
  
  local function diskSide2()
  while true do
    setupTitleBar()
	printer.centered("On What Side Is The Second Disk Drive On?", 6)
	term.setCursorPos(termX/2-(#diskText),10)
	  write (diskText)
	  local vside = false
		diskDriveSide2 = read()
		for k,v in pairs(rs.getSides()) do
			if v == diskDriveSide2 then
				vside = true
				current.Settings.diskSide2 = diskDriveSide2
				break
			end
		end
		if vside then break end
		  printer.centered("Invalid side!", 10)
		  sleep(0.5)
		  term.clear()
		end
  end
  
  local function nameDrive()
    while true do
      setupTitleBar()
	  printer.centered("For Added Security, Pick The FileName", 6)
	  printer.centered("This Is Where The Security Key Will Be Stored", 7)
	  nameDriveText = 'File Name: '
      term.setCursorPos(termX/2-#nameDriveText, 10)
	  write(nameDriveText)
	  nameDriveInput = read()
	    if nameDriveInput ~= "" then current.Settings.nameDriveInput = tostring(nameDriveInput) break end
	end
  end
  
  local function nameDriveData()
    while true do
      setupTitleBar()
	  printer.centered("For Added Security, Pick The Security Key", 6)
	  printer.centered("That Will Be Put On The Path You Specified", 7)
	  nameDriveDataText = 'Security Key: '
      term.setCursorPos(termX/2-#nameDriveDataText, 10)
	  write(nameDriveDataText)
	  nameDriveDataInput = read()
	    if nameDriveDataInput ~= "" then current.Settings.nameDriveDataInput = tostring(nameDriveDataInput) break end
	end
  end
  
  local function redstoneOutput()
   while true do
	setupTitleBar()
	printer.centered("What Side Should The Redstone Output Be?", 6)
	RedstoneOutText = 'Output Side: '
	term.setCursorPos(termX/2-(#RedstoneOutText),10)
	  write (RedstoneOutText)
	  local vside = false
		RedstoneOutSide = read()
		for k,v in pairs(rs.getSides()) do
			if v == RedstoneOutSide then
				vside = true
				current.Settings.redstoneOutSide = RedstoneOutSide
				break
			end
		end
		if vside then break end
		  printer.centered("Invalid side!", 10)
		  sleep(0.5)
		  term.clear()
		end
   end
   
   local function redstoneTime()
     while true do
	  setupTitleBar()
	  printer.centered("What Side Should The Redstone Output Be?", 6)
	  RedstoneTimeText = 'Time: '
	  term.setCursorPos(termX/2-(#RedstoneTimeText),10)
	  write (RedstoneTimeText)
	  RedstoneTimeInput = readN(3)
	  if RedstoneTimeInput == "Word" then term.setCursorBlink(false) printer.centered("Numbers Only!", 19) sleep(0.5) term.setCursorBlink(true)
	    elseif not RedstoneTimeInput then printer.centered("Cannot Be Nil", 19) sleep(0.5)
		  elseif RedstoneTimeInput ~= "" then
		    current.Settings.redstoneOutTime = RedstoneTimeInput
		    break 
		  end
   end
  end
  
  local function diskInit()
   disksReg = 0
    while true do
	  titleBar.draw("HbombOS Security Suite", "Keycard Setup", colors.cyan, 256, 128, 256, 1)
	  printer.centered("Insert Disks Into A Disk Drive Now To Sync Them", 6)
	  printer.centered("With The Data You Have Specified", 7)
	  printer.centered("Press ALT To Continue To Next Step", 9)
	  printer.centered("Disks Inserted: "..disksReg, 11)
	  event, side = os.pullEvent()
	    if event == "disk" then
		  if side == current.Settings.diskSide1 or current.Settings.diskSide2 then
		    local f = fs.open("disk/"..current.Settings.nameDriveInput, "w")
			if f then
			  f.writeLine(current.Settings.nameDriveDataInput)
			  f.close()
			else
			  printer.centered('Files Already Detected!', 18)
			  printer.centered('Press Y To Delete Or N To Pick Another Path', 19)
			  event, press = os.pullEvent()
			  if event ==  "key" then
			    if press == keys.y then
				  fs.delete('disk/'..current.Settings.nameDriveInput)
				  f.writeLine(current.Settings.nameDriveDataInput)
			      f.close()
				elseif press == keys.n then
			      nameDrive()
			      nameDriveData()
				end
			  end
			end
			printer.centered("Files Written To Disk Drive", 19)
			disksReg = disksReg + 1
			disk.eject(side)
			SaveSettings()
			loadSettings()
		  end
		elseif event == 'key' then
		  if side == keys.leftAlt or side == keys.rightAlt then
		    return true
		  end
		end
	end
  end  
  
  local function saveSetup()
    setupTitleBar()
    printer.centered('Thank You For Setting Up Your DualKeyCard', 6)
	printer.centered('Secuity System! Please Report Any Bugs', 8)
    printer.centered('Saving Settings', 19)
	sleep(1)
    SaveSettings()
	printer.centered('Click Anywhere To Reboot', 19)
	os.pullEvent('mouse_click')
	os.reboot()
  end
  
--Call all the functions in order to setup the system!
welcome()
diskSide1()
diskSide2()
nameDrive()
nameDriveData()
redstoneOutput()
redstoneTime()
diskInit()
saveSetup()
end

function waitForRedstone()
  while true do
    sleep(0)
	rsReceive = redstone.getInput(inputSide)
	  if rsReceive then break end
  end
  return true
end

doorTimer = nil
function openSide()
  rs.setOutput(current.Settings.redstoneOutSide, true)
  doorTimer = os.startTimer(tonumber(current.Settings.redstoneOutTime))
  current.Status = 'Emiting Redstone'
  diskEject()
end

function closeSide()
  rs.setOutput(current.Settings.redstoneOutSide, false)
  diskEject()
end

function diskEject(side) --Leave Side Blank To Eject All Sides
  if side then
    disk.eject(side) --Ejects Set Side
  else
    for k,v in pairs(redstone.getSides()) do --Ejects All Sides
      disk.eject(v)
    end
	current.Disks = 0
	current.InvalidDisks = 0
	current.ValidDisks = 0
  end
end

function timerHandler(event, timer)
  if timer == doorTimer then
    current.Status = 'System Ready'
    drawScreen()
    closeSide()
  end
end

function diskInsert(event, side)
  current.Disks = current.Disks + 1
  if current.Disks >= 3 then errora.err('Invalid Amount Of Disks', 'The Program Miscounted The Disk No.') end
  checkDiskIntegrity()
  if current.ValidDisks == 2 then openSide() end
end

function diskRemove(event, side)
  --if current.Disks > 0 then current.Disks = current.Disks - 1 end
  diskEject()
end

function drawScreen()
  if current.Disks > 0 then current.InvalidDisks = current.Disks - current.ValidDisks end
  drawTitle()
  if current.Status == 'System Ready' then term.setTextColor(colors.blue) elseif current.Status == 'Emiting Redstone' then term.setTextColor(colors.lime) else term.setTextColor(colors.white) end
  printer.centered(current.Status, 7)
  term.setTextColor(colors.white)
  printer.centered('Waiting For Disk Insert On Side', 9)
  printer.centered(current.Settings.diskSide1..' Or '..current.Settings.diskSide2, 10)
  if current.InvalidDisks > 0 then term.setTextColor(colors.red) else term.setTextColor(1) end
  printer.centered('Invalid Disks Inserted: '..current.InvalidDisks, 18)
  if current.ValidDisks > 0 then term.setTextColor(colors.blue) else term.setTextColor(1) end
  printer.centered('Valid Disks Inserted: '..current.ValidDisks, 19)
  term.setTextColor(1)
end

function loadAPIS()
  os.loadAPI('api/errora')
  os.loadAPI('api/update')
  os.loadAPI('api/titleBar')
  os.loadAPI('api/systemCheck')
  os.loadAPI('api/download')
  os.loadAPI('api/printer')
end

function checkDiskIntegrity()
local function checkDisk1()
  if fs.exists('disk/'..current.Settings.nameDriveInput) then
    local f = fs.open('disk/'..current.Settings.nameDriveInput, 'r')
	checkDiskData = f.readLine()
	f.close()
	  if checkDiskData == current.Settings.nameDriveDataInput then
	  current.ValidDisks = current.ValidDisks + 1
		return true
	  else
        return false
	  end
  else
    return false
  end
end

local function checkDisk2()
  if fs.exists('disk2/'..current.Settings.nameDriveInput) then
    local f = fs.open('disk2/'..current.Settings.nameDriveInput, 'r')
	checkDiskData = f.readLine()
	f.close()
	  if checkDiskData == current.Settings.nameDriveDataInput then
	  current.ValidDisks = current.ValidDisks + 1
	    return true
	  else
        return false
	  end
  else
    return false
  end
end
if current.Disks == 1 then checkDisk1() elseif current.Disks == 2 then checkDisk2() elseif current.Disks ~= 0 then errora.err('Uh Oh', 'Something Went Wrong When Checking The Disk', true)
end
end

if not term.isColor() then
  printer.centered('The Software Requires An Advanced Machine Run', 19)
  sleep(3)
  os.shutdown()
end
  local _, err = pcall(initialise) --Error Catching, All Functions Are Called From initialise() at some point...
  if err then
    term.setCursorBlink(false)
    loadAPIS()
	errora.err(err, 'Uh Oh, Something Went Horribly Wrong Somewhere, Please Report The ERROR Above!', true) --BSoD for protection, the 'true' is an auto-reboot option to prevent the door waiting for a prompt
  end