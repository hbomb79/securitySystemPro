--os.pullEvent = os.pullEventRaw Termination Defence Layer 1!
isRunning = true

rsText = 'Side: '
rsTimeText = 'Time: '

current = {}

security = {}


_int = 1
_string = 'a'
function readN(len, replaceChar)
  Num = false
  term.setTextColor(1)
  len = len or 10
  local input=""
  local key = 0
  term.setCursorBlink(true)
  repeat
        e,p1 = os.pullEvent()
		  if p1 == "0" or p1 == "1" or p1 == "2" or p1 == "3" or p1 == "4" or p1 == "5" or p1 == "6" or p1 == "7" or p1 == "8" or p1 == "9" then
		    p1 = tonumber(p1)
		    Num = true
		  elseif type(p1) == type(_string) then
		    term.setTextColor(colors.red)
		    Num = "Word"
		    return Num
		  end
        if e=="char" then
          if #input < len then
		    if type(p1) == type(_int) then
                input = input .. p1
                term.write(replaceChar or p1)
			end
          end
        elseif e=="key" and p1==keys.backspace and #input > 0 then
          input = input:sub(1,#input-1)
          local x,y = term.getCursorPos()
          term.setCursorPos(x-1,y)
          term.write(" ")
          term.setCursorPos(x-1,y)
        end
  until p1==keys.enter
  term.setCursorBlink(false)
  return input
end


Peripheral = { --Credit To oeed For This Bit Of Code!!
	GetPeripheral = function(_type)
		for i, p in ipairs(Peripheral.GetPeripherals()) do
			if p.Type == _type then
				return p
			end
		end
	end,

	Call = function(type, ...)
		local tArgs = {...}
		local p = GetPeripheral(type)
		peripheral.call(p.Side, unpack(tArgs))
	end,

	GetPeripherals = function(filterType)
		local peripherals = {}
		for i, side in ipairs(peripheral.getNames()) do
			local name = peripheral.getType(side):gsub("^%l", string.upper)
			local code = string.upper(side:sub(1,1))
			if side:find('_') then
				code = side:sub(side:find('_')+1)
			end

			local dupe = false
			for i, v in ipairs(peripherals) do
				if v[1] == name .. ' ' .. code then
					dupe = true
				end
			end

			if not dupe then
				local _type = peripheral.getType(side)
				local isWireless = false
				if _type == 'modem' then
					if not pcall(function()isWireless = peripheral.call(sSide, 'isWireless') end) then
						isWireless = true
					end     
					if isWireless then
						_type = 'wireless_modem'
						name = 'W '..name
					end
				end
				if not filterType or _type == filterType then
					table.insert(peripherals, {Name = name:sub(1,8) .. ' '..code, Fullname = name .. ' ('..Capitalise(side)..')', Side = side, Type = _type, Wireless = isWireless})
				end
			end
		end
		return peripherals
	end,

	GetPeripheral = function(_type)
		for i, p in ipairs(Peripheral.GetPeripherals()) do
			if p.Type == _type then
				return p
			end
		end
	end,

	PresentNamed = function(name)
		return peripheral.isPresent(name)
	end,

	CallType = function(type, ...)
		local tArgs = {...}
		local p = Peripheral.GetPeripheral(type)
		return peripheral.call(p.Side, unpack(tArgs))
	end,

	CallNamed = function(name, ...)
		local tArgs = {...}
		return peripheral.call(name, unpack(tArgs))
	end
}


function hostSetup() --Creates The Setup GUI If The Config File Is Not Found
  local function setupTitleBar()
	titleBar.draw('HbombOS Secuity Suite', 'Range Detector Setup', colors.cyan, 256, 128, 256, 1)
  end
  
  local function welcome()
    setupTitleBar()
    printer.centered('It appears you have not yet used this', 6)
    printer.centered('program before', 7)
    printer.centered('Click Anywhere On Screen To Get Started!', 10)
	os.pullEvent('mouse_click')
  end
  
  local function redstoneOutSide()
   while true do
    setupTitleBar()
	printer.centered("Redstone Output Side", 6)
	term.setCursorPos(termX/2-(#rsText),10)
	  write (rsText)
	  local vside = false
		redstoneOutsideSetup = read()
		for k,v in pairs(rs.getSides()) do
			if v == redstoneOutsideSetup then
				vside = true
				break
			end
		end
		if vside then break end
		  printer.centered("Invalid side!", 11)
		  sleep(0.5)
		  term.clear()
		end
	 return
  end
  
  local function redstoneInputOption()
  while true do
    setupTitleBar()
	printer.centered('Would You Like The Computer To Emit A Redstone', 6)
	printer.centered('Signal If It Receives A Redstone Signal', 7)
	printer.centered('You Pick Which Side The Input Has To Be Applied To', 9)
	printer.centered('On The Next Screen', 10)
	printer.centered('Press Y To Enable, N To Disable', 12)
	event, key = os.pullEvent('key')
	  if key == keys.y then
	    inputOption = true
		return true
	  elseif key == keys.n then
	    inputOption = false
	    return false
	  end
	end
  end
  
  local function redstoneInputSide()
  sleep(0)
    while true do
    setupTitleBar()
	printer.centered("Redstone Input Side", 6)
	term.setCursorPos(termX/2-(#rsText),10)
	  write (rsText)
	  local vside = false
		redstoneInsideSetup = read()
		for k,v in pairs(rs.getSides()) do
			if v == redstoneInsideSetup then
				vside = true
				break
			end
		end
		if vside then break end
		  printer.centered("Invalid side!", 11)
		  sleep(0.5)
		  term.clear()
		end
	 return
  end
  
  local function registerPDA()
    printer.centered('Insert PDAs Into A Disk Drive Attached To This Disk')
    printer.centered('Drive To Add The Fingerprint')
	printer.centered('The Startup File On The PDA WILL Be Replaced')
	printer.centered('But Will Be Moved To A Directory Called')
	printer.centered('/oldStartup')
  end
  
  local function saveSetup()
    setupTitleBar()
    printer.centered('Thank You For Setting Up Your RangeLock', 6)
	printer.centered('Secuity System! Please Report Any Bugs', 8)
    printer.centered('Saving Settings', 19)
	sleep(0)
    local f = fs.open('systemFiles/Programs/rangeLockSettings', 'w')
	f.writeLine(redstoneOutsideSetup)
	f.writeLine(tostring(inputOption))
	fingerprintNew = generateFingerprint()
	f.writeLine(fingerprintNew)
	if inputOption then
	  f.writeLine(redstoneInsideSetup)
	end
	printer.centered('Settings Saved', 19)
	sleep(0.5)
	printer.centered('Click Anywhere To Reboot', 19)
	os.pullEvent('mouse_click')
	os.reboot()
  end
  
--Call all the functions in order to setup the system!
welcome()
redstoneOutSide()
if redstoneInputOption() then redstoneInputSide() end
saveSetup()
end

-- Modem Functions Called For Info On Modems, Or To Change Modem Status
modem = {
  channels = {
    ping = 6019,
    request = 6021,
	reply = 6023,
  },
  isOpen = function(channel) --Returns if the channel is open or not
    Peripheral.CallType('wireless_modem', 'isOpen', channel)
  end,
  
  Open = function(channel) --Open a channel if not already open
    if not modem.isOpen then
	  Peripheral.CallType('wireless_modem', 'open', channel)
	end
  end, 
  
  Close = function(channel) --Close channel specified
    Peripheral.CallType('wireless_modem', 'close', channel)
  end,
  
  CloseAll = function() --Close all channels
    Peripheral.CallType('wireless_modem', 'closeAll')
  end, 
  
  Transmit = function(channel, replyChannel, message) --Transmit a message over the modem... The message is serialized first so it can hold data.... Use FormatMessage()
    Peripheral.CallType('wireless_modem', 'transmit', channel, replyChannel, textutils.serialize(message))
  end,

  RecieveMessage = function(_channel, messageID, timeout)
		open(_channel)
		local done = false
		local event, side, channel, replyChannel, message = nil
		Timeout(function()
			while not done do
				event, side, channel, replyChannel, message = os.pullEvent('modem_message')
				if channel ~= _channel then
					event, side, channel, replyChannel, message = nil
				else
					message = textutils.unserialize(message)
					message.content = textutils.unserialize(message.content)
					if messageID and messageID ~= message.messageID or (message.destinationID ~= nil and message.destinationID ~= os.getComputerID()) then
						event, side, channel, replyChannel, message = nil
					else
						done = true
					end
				end
			end
		end,
		timeout)
		return event, side, channel, replyChannel, message
	end,

  SendMessage = function(channel, message, reply, messageID, destinationID)
    reply = reply or channel + 1
	Wireless.Open(channel)
	Wireless.Open(reply)
	local _message = Wireless.FormatMessage(message, messageID, destinationID)
	Wireless.transmit(channel, reply, _message)
	return _message
  end,

  HandleMessage = function(event, side, channel, replyChannel, message, distance)
    message = textutils.unserialize(message)
	message.content = textutils.unserialize(message.content)
	  if channel == Wireless.Channels.Ping then
	    if message.content == 'Ping!' then
		  SendMessage(replyChannel, 'Pong!', nil, message.messageID)
		end
	  elseif message.destinationID ~= nil and message.destinationID ~= os.getComputerID() then
	  elseif Wireless.Responder then
	    Wireless.Responder(event, side, channel, replyChannel, message, distance)
	  end
  end,

  FormatMessage = function(message, messageID, destinationID)
    return {
	  content = textutils.serialize(message),
  	  senderID = os.getComputerID(),
	  senderName = os.getComputerLabel(),
	  channel = channel,
	  replyChannel = reply,
	  messageID = messageID or math.random(10000),
	  destinationID = destinationID
    }
  end
}
Events ={}

local DoorTimer = nil
function OpenDoor()
	if current.RedstoneSide then
		redstone.setOutput(current.RedstoneSide, true)
		DoorTimer = os.startTimer(0.5)
	end
end

function loadSettings()
  if fs.exists('systemFiles/Programs/rangeLockSettings') then
		local f = fs.open('systemFiles/Programs/rangeLockSettings', 'r')
		if f then
			current.Settings = textutils.unserialize(f.readAll())
		end
		f.close()
	else
		hostSetup()
	end
end

function SaveSettings()
	current.Settings = current.Settings or {}
	local f = fs.open('systemFiles/Programs/rangeLockSettings', 'w')
	if f then
		f.write(textutils.serialize(current.Settings))
	end
	f.close()	
end

function CloseDoor()
	if current.RedstoneSide then
		if redstone.getOutput(current.Settings.RedstoneSide) then
			redstone.setOutput(current.Settings.RedstoneSide, false)
		end
	end
end

function eventRegister(event, functionToRun)
	if not Events[event] then
		Events[event] = {}
	end
	table.insert(Events[event], functionToRun)
end

function fingerprintCheck(fingerprint)
  
end

function RegisterPDA(event, drive)
	if disk.hasData(drive) then
		local path = disk.getMountPath(drive)
		local fingerprint = nil
		if fs.exists(path..'/.fingerprint') then
			local h = fs.open(path..'/.fingerprint', 'r')
			if h then
				local str = h.readAll()
				if #str == 256 then
					fingerprint = str
				end
			end
			h.close()
		end
		if not fingerprint then
			fingerprint = GenerateFingerprint()
			local h = _fs.open(path..'/.fingerprint', 'w')
			h.write(fingerprint)
			h.close()
			if addStartup then
				local h = fs.open(shell.getRunningProgram(), 'r')
				local startup = h.readAll()
				h.close()
				local h = _fs.open(path..'/startup', 'w')
				h.write(startup)
				h.close()
			end
		end
		if not FingerprintIsOnWhitelist(fingerprint) then
			table.insert(current.Whitelist, fingerprint)
			SaveSettings()
		end
		disk.eject(drive)
		printer.centered('PDA Registered', 19)
	end
end

function startHost() --Run if the user is on the host computer... Aka, the one that controls the door
  if fs.exists('systemFiles/Programs/rangeLockSettings') then
  
  else
    hostSetup()
	saveSettings()
  end
end

function pingPDA()
  
end

function timerHandler() --Handles timer completion events and carries out the appropriate action
  if timer == 'pingTimer' then
    pingPDA()
  elseif timer == 'DoorTimer' then
    CloseDoor()
  end
end

function initialise() --Registers All Events To Autorun Functions, e.g If i press a key it will run keyPress
  eventRegister('key', keyPress)
  eventRegister('timer', timerHandler)
  eventRegister('terminate', function(event) errora.err('Termination Detected', 'You Attempted To Terminate The Program!' , true) end)
  eventRegister('modem_message', HandleMessage)
  eventRegister('disk', RegisterPDA)
  
  --Loading Configuration
  local f = fs.open('systemFiles/Programs/rangeLockSettings', 'r')
  current.RedstoneOutput = f.readLine()
  current.Fingerprint = f.readLine()
  current.useInput = f.readLine()
  if current.useInput == 'true' then
    current.inputSide = f.readLine()
  end
  
  
  startHost() --Set up the host system
  
  eventLoop() --Starts the program waiting for the events to occur
  
end


function eventLoop() --This runs the functions that was assigned to the event in initialise()
  while isRunning do
	local event, arg1, arg2, arg3, arg4, arg5, arg6 = os.pullEventRaw()
	  if Events[event] then
		for i, e in ipairs(Events[event]) do
		  e(event, arg1, arg2, arg3, arg4, arg5, arg6)
		end
      end
   end
end

function createFingerprint() --Saves the fingerprint to the PDA
  if not fs.exists('.fingerprint') then
    local fingerprint = generateFingerprint() --Generates the finger print and stores it in a variable
	if #fingerprint < 256 then --Checks if the fingerprint is at least 256 chars long
	  local fingerprint = generateFingerprint()
	end
	local f = fs.open('.fingerprint', 'w') --Opens the '.fingerprint' file on PDA
	f.write(fingerprint) --Writes the fingerprint
	security.Fingerprint = fingerprint --Stores the fingerprint in the table 'security'
  else
    os.reboot()
  end
end

function generateFingerprint()
 local fingerprint = ""
 printer.centered('Please Wait While We Generate A Fingerprint', 19)
  for i=1, 256 do --Repeats 256 times
    char = math.random(32, 126) --Creates A Random Digit
	fingerprint = fingerprint .. string.char(char) --Adds the random digit on the end of the others
  end
  printer.centered('Fingerprint Created', 19)
  return fingerprint --Returns the fingerprint completed after the loop has finished
end


if not term.isColor() then
  printer.centered('The Software Requires An Advanced Machine Run', 19)
  sleep(3)
  os.shutdown()
end
  term.clear()
  titleBar.draw('HbombOS Security Suite', 'Range Lock', colors.cyan, 256, 128, 256, 1)
  term.setTextColor(1)
  printer.centered('Range Lock Security', 6)
  term.setTextColor(colors.blue)
  printer.centered('System Ready', 7)
  term.setTextColor(1)
  printer.centered('By hbomb_79', 19)
  local _, err = pcall(initialise) --Error Catching, All Functions Are Called From initialise() at some point...
  if err then
    term.setCursorBlink(false)
    errora.err(err, 'Range Lock Has Crashed', true) --BSoD for protection, the 'true' is an auto-reboot option to prevent the door waiting for a prompt
  end